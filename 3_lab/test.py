import unittest
from axe import Axe
from swords_bonus import SwordBonus
# клас для тестування повинен починатися зі слова Test
class TestSwordBonus(unittest.TestCase):
    # В даному класі реаліуються всі юніттести у вигляді методів
    # кожен юніттест (назва ф-кції) повинен починатись з префікса імені "test_"
    # оскільки ми працюємо в класі, ми працюємо з методами, і маємо вказівник на об'єкт self, 
    # який містить весь функціонал батьківського класу TestCase, з якого ми будемо використовувати перевірки assert

    def setUp(self) -> None:
        print("Проводимо початкову ініціалізацію для тестів....")
        self.sw = Axe() # створений макет на який можемо накласти баф отрути
        self.sb = SwordBonus() # імплементація бонусів
        self.d, self.v = self.sw.damag, self.sw.vitality  # Початкове значення характеристик витягуємо через подвійне присвоєння
        return super().setUp()
    
    def tearDown(self) -> None:
        print("Видаляємо обєкти після завершення тестування.")
        del self.sw
        del self.sb
        self.d, self.v = None, None
        return super().tearDown()


    def test_bonus_poison(self):
        """Тестуємо правильність накладення бафу отрути"""
        sw = Axe() # створений макет на який можемо накласти баф отрутити 
        sb = SwordBonus() # імплементація бонусів

        d = sw.damag # тут ми фіксуємо початкове значення нанесення шкоди 
        result = self.sb.bonus_poison(self.sw) # після накладення бонусу наш метод має повернути результат
        # нам відомий результат, що повертається, тому ми просто перевіряємо чи він буде рівний
        self.assertEqual(result, f"Застосовано бонус отрути {self.sw.name}")
        # після накладення бафу отрути наш damage має збільшитись, тому перевіряємо, 
        # що поточне значення шкоди має бути більшим за початкове
        self.assertGreater(self.sw.damag, self.d, "Накладений бонус отрути не збільшив значення шкоди.")

    def test_bonus_strength(self):
        """Тестуємо накладання бафу міцності"""
        result = self.sb.bonus_strength(self.sw)
        self.assertEqual(result, f"Застосовано бонус сили до {self.sw.name}")
        self.assertGreater(self.sw.vitality, self.v, "Накладений бонус міцності не збільшив значення міцності.")
        # Якщо ми передали неправильний обєкт, до якого не можна накласти баф, то ам просто поварнеться значення None
        self.assertIsNone(self.sb.bonus_strength(1), "До цього обєкне не можна застосовувати накладення бафів, неправильний обєкт")
    
    def test_bonus_confusion(self):
        """Тестуємо накладання бафу конфузії"""
        ##### Цей підрозділ робить початкову ініціалізацію
        # Весь цей підрозділ ми можемо винести у спеціальний метод який називається setUp
        #sw = Axe() # створений макет на який можемо накласти баф отрути
        #sb = SwordBonus() # імплементація бонусів
        #d, v = sw.damag, sw.vitality  # Початкове значення характеристик витягуємо через подвійне присвоєння
        
        ##### Це новий підрозділ, де ми власне викликаємо методи який хочемо протестувати
        # передаємо в нього потрібно нам аргументи та записуємо результа
        result = self.sb.bonus_confusion(self.sw)
        
        ##### Це є останній розділів тесту, який власне тустує що ми отримали
        # тут тестуємо що повинна повертати наш метод накладення бафу
        self.assertTrue(isinstance(result, str), "Повернене значення не відповіє стрічковому типу даних")
        self.assertIn(self.sw.name, result, f"Отримана відповідь не вказує не містить {self.sw.name}")
        self.assertIn("бонус", result, "Повернене значення не містить слова бонус")
        
        # тут тестуємо зміни які були здійснені накладанням бафу
        self.assertGreaterEqual(self.sw.damag, self.d, "Баф мав залишити рівним або збільшити значення Нанесення шкоди.")
        self.assertGreaterEqual(self.sw.vitality, self.v, "Баф мав залишити рівним або збільшити значення Міцності.")
        # Якщо ми передали неправильний обєкт, до якого не можна накласти баф, то ам просто поварнеться значення None
        self.assertIsNone(self.sb.bonus_confusion(1), "До цього обєкне не можна застосовувати накладення бафів, неправильний обєкт")

    
# Ця конструкція if не дозволить запустити цей код, якщо ми імпортнемо в інший файл
if __name__ == '__main__':
    unittest.main(verbosity=2)